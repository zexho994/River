@startuml

interface River<T>{
    + (static) Stream<T> of(T...)
    + Stream<T> filter(Predicate<? super T>)
    + Stream<T> distinct();
    + forEach(Consumer<? super T>)
    + long count()
}

class RiverGenerator{
    + (static)<T> River<T> create(T...)
}

River .left.> RiverGenerator : depend on

abstract Pipeline<T>{
    + River<T> source
    + River<T> previous
    + River<T> next
    + Op
}
Pipeline .* Op : depend on

class AbstractRiver<T>{}
River <|-- AbstractRiver : impl
Pipeline <|-- AbstractRiver : extends

class PipelineSource<T>{}
class PipelineStage<T>{}
AbstractRiver<|-- PipelineSource : extends
AbstractRiver <|-- PipelineStage : extends

enum Op{
    + source(0)
    + filter(1)
    + distinct(2)
}

interface Consumer{}
interface Sink<T>{}
Consumer <|-- Sink : impl

abstract SinkChain{}
Sink <|-- SinkChain : impl

class FilterSink{}
SinkChain <|-- FilterSink : extends

class DistinctSink{}
SinkChain <|-- DistinctSink : extends


@enduml