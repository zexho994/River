@startuml

package River{
    interface River<T>{
        + (static) Stream<T> of(T...)
        + Stream<T> filter(Predicate<? super T>)
        + Stream<T> distinct();
        + forEach(Consumer<? super T>)
        + long count()
    }

    class RiverGenerator{
        + (static)<T> River<T> create(T...)
    }
    River .left.> RiverGenerator : depend on
}


package Pipeline{
    abstract Pipeline<T>{
        + River<T> source
        + River<T> previous
        + River<T> next
        + Op
    }
    Pipeline .left* Op : depend on

    class AbstractRiverPipeline<T>{}
    River <|-down- AbstractRiverPipeline : impl
    Pipeline <|- AbstractRiverPipeline : extends

    class PipelineSource<T>{
        + PipelineSource(Spliterator<T>)
    }
    class PipelineStage<T>{
        + PipelineStage(AbstractRiverPipeline<T>, Op)
    }
    AbstractRiverPipeline<|-down- PipelineSource : extends
    AbstractRiverPipeline <|-down- PipelineStage : extends

    enum Op{
        + source(0)
        + filter(1)
        + distinct(2)
        + forEach(20)
        + count(21)
    }
}

package Sin{
    interface Consumer{
        + void accept()
    }
    interface Sink<T>{
        + void begin()
        + void end()
    }
    Consumer <|- Sink : impl

    abstract SinkChain{
        + AbstractRiverPipeline<T> river
        + SinkChain<T> next
        + final Consumer<T> consumer
        + Predicate<T> predicate
    }
    Sink <|-- SinkChain : impl
    SinkChain *- AbstractRiverPipeline

    class FilterSink{}
    class DistinctSink{}
    class ForEachSink{}
    class CountSink{}
    SinkChain <|-- FilterSink : extends
    SinkChain <|-- DistinctSink : extends
    SinkChain <|-- ForEachSink : extends
    SinkChain <|-- CountSink : extends
}

@enduml