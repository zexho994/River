@startuml

interface River<T>{
    + (static) Stream<T> of(T...)
    + Stream<T> filter(Predicate<? super T>)
    + Stream<T> distinct();
    + forEach(Consumer<? super T>)
    + long count()
}

class RiverGenerator{
    + (static)<T> River<T> create(T...)
}

River .left.> RiverGenerator : depend on

abstract Pipeline<T>{
    + River<T> source
    + River<T> previous
    + River<T> next
    + Op
}
Pipeline .* Op : depend on

class AbstractRiverPipeline<T>{}
River <|-- AbstractRiverPipeline : impl
Pipeline <|-- AbstractRiverPipeline : extends

class PipelineSource<T>{
    + PipelineSource(Spliterator<T>)
}
class PipelineStage<T>{
    + PipelineStage(AbstractRiverPipeline<T>, Op)
}
AbstractRiverPipeline<|-- PipelineSource : extends
AbstractRiverPipeline <|-- PipelineStage : extends

enum Op{
    + source(0)
    + filter(1)
    + distinct(2)
    + forEach(20)
    + count(21)
}

interface Consumer{
    + void accept()
}
interface Sink<T>{
    + void begin()
    + void end()
}
Consumer <|-- Sink : impl

abstract SinkChain{
    + AbstractRiverPipeline<T> river
    + SinkChain<T> next
    + final Consumer<T> consumer
    + Predicate<T> predicate
}
Sink <|-- SinkChain : impl

class FilterSink{}
class DistinctSink{}
class ForEachSink{}
class CountSink{}
SinkChain <|-- FilterSink : extends
SinkChain <|-- DistinctSink : extends
SinkChain <|-- ForEachSink : extends
SinkChain <|-- CountSink : extends

@enduml